#!/bin/bash

#   __|    \    _ \  |      _ \   __| __ __| __ __|
#  (      _ \     /  |     (   | (_ |    |      |
# \___| _/  _\ _|_\ ____| \___/ \___|   _|     _|

# icarus
# Created 1/26/24 - 7:20 PM UK Time (London) by carlogtt

# Basic Foreground Colors
declare -r black=$'\033[30m'
declare -r red=$'\033[31m'
declare -r green=$'\033[32m'
declare -r yellow=$'\033[33m'
declare -r blue=$'\033[34m'
declare -r magenta=$'\033[35m'
declare -r cyan=$'\033[36m'
declare -r white=$'\033[37m'

# Bold/Bright Foreground Colors
declare -r bold_black=$'\033[1;30m'
declare -r bold_red=$'\033[1;31m'
declare -r bold_green=$'\033[1;32m'
declare -r bold_yellow=$'\033[1;33m'
declare -r bold_blue=$'\033[1;34m'
declare -r bold_magenta=$'\033[1;35m'
declare -r bold_cyan=$'\033[1;36m'
declare -r bold_white=$'\033[1;37m'

# Basic Background Colors
declare -r bg_black=$'\033[40m'
declare -r bg_red=$'\033[41m'
declare -r bg_green=$'\033[42m'
declare -r bg_yellow=$'\033[43m'
declare -r bg_blue=$'\033[44m'
declare -r bg_magenta=$'\033[45m'
declare -r bg_cyan=$'\033[46m'
declare -r bg_white=$'\033[47m'

# Text Formatting
declare -r bold=$'\033[1m'
declare -r dim=$'\033[2m'
declare -r italic=$'\033[3m'
declare -r underline=$'\033[4m'
declare -r invert=$'\033[7m'
declare -r hidden=$'\033[8m'

# Reset Specific Formatting
declare -r end=$'\033[0m'
declare -r end_bold=$'\033[21m'
declare -r end_dim=$'\033[22m'
declare -r end_italic_underline=$'\033[23m'
declare -r end_invert=$'\033[27m'
declare -r end_hidden=$'\033[28m'

# Emoji
declare -r green_check_mark="\xE2\x9C\x85"
declare -r hammer_and_wrench="\xF0\x9F\x9B\xA0"
declare -r clock="\xE2\x8F\xB0"
declare -r sparkles="\xE2\x9C\xA8"
declare -r stop_sign="\xF0\x9F\x9B\x91"
declare -r warning_sign="\xE2\x9A\xA0\xEF\xB8\x8F"
declare -r key="\xF0\x9F\x94\x91"
declare -r circle_arrows="\xF0\x9F\x94\x84"
declare -r broom="\xF0\x9F\xA7\xB9"
declare -r link="\xF0\x9F\x94\x97"
declare -r package="\xF0\x9F\x93\xA6"
declare -r network_world="\xF0\x9F\x8C\x90"

# Script Options
set -o errexit   # Exit immediately if a command exits with a non-zero status
set -o pipefail  # Exit status of a pipeline is the status of the last cmd to exit with non-zero

# Script Paths
script_dir_abs="$(realpath -- "$(dirname -- "${BASH_SOURCE[0]}")")"
declare -r script_dir_abs

# Export path for non interactive shell
export PATH="/opt/homebrew/bin:/Users/carlogtt/.local/bin:/usr/local/bin:/usr/bin:/bin:/opt/homebrew/sbin:/usr/sbin:/sbin:$PATH"

# CLI variables
cli_name='icarus'
this_cli_fullpath="${HOME}/.icarus/bin/${cli_name}"

########################################################################
# AMAZON
########################################################################
amazon() {

    auth_init_local_machine() {

        # Temporarily disable 'errexit' to allow for retries
        set +e

        # Local machine
        echo -e "${bold_yellow}${circle_arrows} Authentication started for LOCAL $(uname -n)...\n${end}"

        # Authenticate Kerberos
        while true; do

            echo -e "${blue}Kerberos Authentication${end}"
            echo -e "${red}[DISABLED] Kerberos${end}" && true
            # kinit -f
            kinit_status=$?

            # Check if Kerberos was successful
            if [[ $kinit_status -eq 0 ]]; then
                # echo -e "${bold_green}${key} Successfully authenticated!${end}"
                break
            else
                echo -e "${bold_red}Authentication failed! Please try again.\n${end}"
                continue
            fi

        done

        # Break line
        echo ""

        # Authenticate Midway
        while true; do

            echo -e "${blue}Midway Authentication${end}"
            mwinit -s --fido2
            mwinit_status=$?

            # Check if Midway was successful
            if [[ $mwinit_status -eq 0 ]]; then
                echo -e "${bold_green}${key} Successfully authenticated!${end}"
                break
            else
                echo -e "${bold_red}Authentication failed! Please try again.\n${end}"
                continue
            fi

        done

        # Break line
        echo ""
        echo ""

        # Re-enable 'errexit'
        set -e
    }

    auth_init_ssh() {
        # Iterate over each argument
        for dev_dsk_number in "$@"; do
            # Construct the HOSTNAME
            hostname="devdsk${dev_dsk_number}"

            # SSH into the cloud desktop and initialize there
            echo -e "${bold_yellow}${circle_arrows} Authentication started for REMOTE SSH ${hostname}...\n${end}"

            ssh -t "${hostname}" "
source /local/home/carlogtt/.zshrc;

echo -e '${blue}Performing Kerberos Authentication${end}';
echo -e '${red}[DISABLED] Kerberos${end}';
#kinit -f;

echo '';

echo -e '${blue}Midway Authentication${end}';
mwinit -s -o; mwinit_status=\$?;
echo \$mwinit_status;
#if [[ \$mwinit_status -eq 0 ]]; then;
#    echo -e '${bold_green}${key} Successfully authenticated!${end}';
#else;
#    echo -e '${bold_red}Authentication failed!\n${end}';
#fi
"
            # Break line
            echo ""
            echo ""
        done
    }

    cookies_analysis() {
        # Define the path to the cookies file
        cookies_filepath="${HOME}/.midway/cookie"

        # Check if the cookies file exists
        if [[ ! -f "$cookies_filepath" ]]; then
            echo "Cookies file not found."
            exit 1
        fi

        # Process each line of the file
        tail -n +5 "$cookies_filepath" | while read -r line; do
            # Extract the expiration timestamp and the cookie name
            expiry_timestamp=$(echo "$line" | awk '{print $5}')
            cookie_name=$(echo "$line" | awk '{print $6}')

            # Convert the expiry timestamp to a human-readable date
            if [[ "$(uname)" == "Darwin" ]]; then
                # macOS (BSD date)
                expiry_date=$(date -r "${expiry_timestamp}" +"%Y-%m-%d %H:%M:%S")
            else
                # Linux (GNU date)
                expiry_date=$(date -d @"${expiry_timestamp}" +"%Y-%m-%d %H:%M:%S")
            fi

            # Calculate the time remaining
            current_timestamp=$(date +%s)
            time_remaining=$((expiry_timestamp - current_timestamp))

            # Convert time remaining to human-readable format
            days_remaining=$((time_remaining / 86400))
            hours_remaining=$(((time_remaining % 86400) / 3600))
            minutes_remaining=$(((time_remaining % 3600) / 60))
            seconds_remaining=$((time_remaining % 60))

            # Use printf to format the output
            printf "Cookie: %-25s expires: %s  ->  remaining: %3d days, %2d hours, %2d minutes, %2d seconds" "$cookie_name" "$expiry_date" "$days_remaining" "$hours_remaining" "$minutes_remaining" "$seconds_remaining"
            echo -e ""
        done
    }

    devdsk_formation() {
        filepath=/Users/carlogtt/Dropbox/SDE/Shell/CarloCodes/MyScripts/DevDskFormation/devdsk_formation.sh
        hostname="devdsk$1"

        echo -e "Transferring devdsk_formation to ${hostname}..."
        scp "${filepath}" "${hostname}":/home/carlogtt/ || exit 1
        echo -e "Transfer completed!\n"

        echo -e "Running devdsk_formation on ${hostname}...\n"
        ssh -t "${hostname}" "./devdsk_formation.sh;"
    }

    update_etc_hosts() {
        echo -e "We need to briefly run as root (through sudo) to write the /etc/hosts"
        echo -e "If prompted, please enter your user password."
        sudo -v

        cat <<'EOF' >"/tmp/update_etc_hosts_temp.py"
import urllib.request
import subprocess
import json
import datetime

url = "https://dns.google/resolve?name=cpgbackup.logitech.com&type=A"
bash_command = f"curl -s {url}"

result = subprocess.run(bash_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

result_dict = json.loads(result.stdout)

all_dns_ips = [el['data'] for el in result_dict['Answer']]

all_dns_ips_padded = []

for el in all_dns_ips:
    ip_len = len(el)
    padding = (20 - ip_len) * " "
    new_el = f"{el}{padding}cpgbackup.logitech.com\n"
    all_dns_ips_padded.append(new_el)

hosts_lines = []
insert_idx = None

with open('/etc/hosts', 'r') as f:
    for idx, line in enumerate(f.readlines()):
        if "## updated on" in line:
            line = f"## updated on UTC {datetime.datetime.now(datetime.timezone.utc).isoformat()}\n"
            hosts_lines.append(line)
            continue
        if "cpgbackup.logitech.com" in line:
            if insert_idx is None:
                insert_idx = idx
            continue
        else:
            hosts_lines.append(line)

hosts_lines[insert_idx:insert_idx] = all_dns_ips_padded
new_hosts_file = "".join(hosts_lines)

with open('/etc/hosts', 'w') as f:
    f.write(new_hosts_file)
EOF
        sudo /usr/bin/python3 "/tmp/update_etc_hosts_temp.py" || exit 1

        echo -e "\n${bold_green}${green_check_mark} /etc/hosts file updated!${end}\n"
        cat "/etc/hosts"
    }

    update_etc_hosts_daemon() {
        hosts_launchd_daemon_path="/Library/LaunchDaemons/com.carlogtt.hosts.daemon.plist"

        echo -e "We need to briefly run as root (through sudo) to write to ${hosts_launchd_daemon_path}."
        echo -e "If prompted, please enter your user password."
        sudo -v

        echo -e "\nWriting launchd daemon configuration"

        cat <<EOF | sudo tee "${hosts_launchd_daemon_path}" >/dev/null
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>Label</key>
        <string>com.carlogtt.hosts.daemon</string>
        <key>StartCalendarInterval</key>
        <dict>
            <key>Minute</key>
            <integer>00</integer>
        </dict>
        <key>StandardOutPath</key>
        <string>/tmp/com.carlogtt.hosts.daemon.log</string>
        <key>StandardErrorPath</key>
        <string>/tmp/com.carlogtt.hosts.daemon.log</string>
        <key>ProgramArguments</key>
        <array>
            <string>${this_cli_fullpath}</string>
            <string>--amazon</string>
            <string>--update-hosts</string>
        </array>
    </dict>
</plist>
EOF

        sudo chown root:wheel ${hosts_launchd_daemon_path}
        sudo chmod 644 ${hosts_launchd_daemon_path}

        echo -e "launchd daemon configuration was successfully written to"
        echo -e "${hosts_launchd_daemon_path}"

        echo -e "\nLoading launchd daemons configuration"
        echo -e "loading ${hosts_launchd_daemon_path}"
        sudo launchctl unload "${hosts_launchd_daemon_path}"
        sudo launchctl load "${hosts_launchd_daemon_path}"
        echo -e "Configuration loaded"
    }

    if [[ -z "$1" ]]; then
        arg='-h'
    else
        arg="$1"
    fi

    case "${arg}" in
    -a | --auth-init)
        case "$2" in
        '')
            auth_init_local_machine
            exit 0
            ;;
        -i)
            if [[ -z "$3" ]]; then
                usage
                exit 1
            fi
            auth_init_local_machine
            auth_init_ssh "${@:3}"
            exit 0
            ;;
        *)
            echo -e "${bold}amazon: illegal option -- $*${end}"
            usage
            exit 1
            ;;
        esac
        ;;

    -c | --midway-cookie)
        cookies_analysis
        exit 0
        ;;

    -d | --devdsk-formation)
        case "$2" in
        -i)
            if [[ -z "$3" ]]; then
                usage
                exit 1
            fi
            devdsk_formation "${@:3}"
            exit 0
            ;;
        *)
            echo -e "${bold}amazon: illegal option -- $*${end}"
            usage
            exit 1
            ;;
        esac
        ;;

    -s | --update-hosts)
        update_etc_hosts
        exit 0
        ;;

    -u | --update-hosts-d)
        update_etc_hosts_daemon
        exit 0
        ;;

    -h | --help)
        usage
        ;;

    *)
        echo -e "${bold}amazon: illegal option -- $*${end}"
        usage
        exit 1
        ;;
    esac
}

########################################################################
# BUILDER
########################################################################
builder() {

    convert_to_snake_case() {
        input_str="$1"

        # Remove leading and trailing whitespace
        sanitized_input_str=$(echo "${input_str}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Validate input: only alphanumeric characters are allowed
        if ! [[ "${sanitized_input_str}" =~ ^[a-zA-Z0-9]+$ ]]; then
            echo ""
            return
        fi

        # Convert camelCase to snake_case
        snake_case_str=$(echo "${sanitized_input_str}" | sed -r 's/([0-9]+)/_\1_/g; s/([a-z])([A-Z])/\1_\2/g' | tr '[:upper:]' '[:lower:]' | sed -r 's/__/_/g; s/^_+|_+$//g')

        # Output the snake_case string
        echo "${snake_case_str}"
    }

    python_project_init() {
        # Remove leading and trailing whitespace
        project_name_pascal_case="$(echo "$1" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
        project_name_snake_case=$(convert_to_snake_case "${project_name_pascal_case}")
        absolute_current_path="$(realpath "$(pwd)")"
        project_absolute_path="${absolute_current_path}/${project_name_pascal_case}"

        if [[ -z "${project_name_snake_case}" ]]; then
            echo -e "Invalid input: only alphanumeric characters are allowed in the project name."
            exit 1
        else
            echo -e "Project name: ${project_name_pascal_case} => (${project_name_snake_case})"
        fi

        echo -e "\nMaking project directory: ${absolute_current_path}/${project_name_pascal_case}..."
        if [[ -d "${project_absolute_path}" ]]; then
            echo "Project already exists."
            exit 1
        fi

        mkdir -p -- "${project_absolute_path}"
        chmod 755 "${project_absolute_path}"
        git clone "git@github.com:64rl0/PythonTemplatePackage.git" "${project_absolute_path}"

        rm -rf "${project_absolute_path}/.git"
        mv "${project_absolute_path}/src/project_name_here" "${project_absolute_path}/src/${project_name_snake_case}"
        touch "${project_absolute_path}/.env"

        echo -e "\nInitiating Git repository..."
        cd "${project_absolute_path}"
        git init
        git add .
        git commit -q -m "FEAT: Initial commit for ${project_name_pascal_case} automatically created by ${cli_name}"

        echo -e "\n${bold_green}${green_check_mark} Project ${project_name_pascal_case} successfully created!${end}"
    }

    # Update all the dotfiles configs
    dotfiles_update() {
        dotfiles=(
            "${HOME}/.bash/config"
            "${HOME}/.bash/completion"
            "${HOME}/.zsh/config"
            "${HOME}/.zsh/completion"
            "${HOME}/.carlogtt_alias"
            "${HOME}/.carlogtt_script"
            "${HOME}/.vim"
            "${HOME}/.icarus"
            "${HOME}/.config/alacritty"
            "${HOME}/.config/apple-terminal"
            "${HOME}/.config/fzf"
            "${HOME}/.config/homebrew"
            "${HOME}/.config/lazygit"
            "${HOME}/.config/starship"
            "${HOME}/.config/tmux"
        )

        for dotfile in "${dotfiles[@]}"; do
            echo -e "${sparkles}${bold_yellow}${dotfile}${end}"
            cd "${dotfile}" >/dev/null 1>&2 && git fetch && git status && git pull
            echo -e ""
            cd "${OLDPWD}" >/dev/null 1>&2
        done
    }

    if [[ -z "$1" ]]; then
        arg='-h'
    else
        arg="$1"
    fi

    case "${arg}" in
    -p | --python-project-init)
        case "$2" in
        -n)
            if [[ -z "$3" ]]; then
                usage
                exit 1
            fi
            python_project_init "$3"
            exit 0
            ;;
        *)
            echo -e "${bold}builder: illegal option -- $*${end}"
            usage
            exit 1
            ;;
        esac
        ;;

    -d | --dotfiles-update)
        dotfiles_update
        exit 0
        ;;

    -h | --help)
        usage
        ;;

    *)
        echo -e "${bold}builder: illegal option -- $*${end}"
        usage
        exit 1
        ;;
    esac
}

########################################################################
# MACOS
########################################################################
macos() {

    macos_find_unencrypted_volumes() {

        vol_list_path="/tmp/volumes.plist"
        diskutil apfs list -plist >"${vol_list_path}"

        unencrypted_volume_count=0

        pb() {
            /usr/libexec/PlistBuddy -c "$1" "${vol_list_path}"
        }

        pbe() {
            pb "$1" >/dev/null 2>&1
        }

        check_container() {
            container_id="$1"
            vol_id=0
            while true; do
                pbe "Print Containers:${container_id}:Volumes:${vol_id}" || break # break if volume doesn't exist
                fv_status=$(pb "Print Containers:${container_id}:Volumes:${vol_id}:FileVault")
                vol_name="$(pb "Print Containers:${container_id}:Volumes:${vol_id}:Name")"
                if [[ ${fv_status} == "false" ]]; then
                    if ! [[ "${vol_name}" =~ ^VM|Preboot|Recovery|Update$ ]]; then
                        echo -e "${red}Volume \"${vol_name}\" is not encrypted and should be!${end}"
                        unencrypted_volume_count=$((unencrypted_volume_count + 1))
                    else
                        echo -e "${blue}Volume \"${vol_name}\" is not encrypted but that's expected.${end}"
                    fi
                else
                    echo -e "${green}Volume \"${vol_name}\" is encrypted.${end}"
                fi
                vol_id=$((vol_id + 1))
            done
        }

        container_id=0
        while true; do
            check_container ${container_id}
            container_id=$((container_id + 1))
            pbe "Print Containers:${container_id}" || break
        done
        rm "${vol_list_path}"

        if ((unencrypted_volume_count != 0)); then
            echo -e "\nYou have ${unencrypted_volume_count} unencrypted volume(s)!"
            echo -e "Please see https://w.amazon.com/bin/view/MacImprovement/CaseSensitiveVolume/ for instructions how to encrypt them."
            exit 0
        else
            echo -e "Congratulations! You do not have any unencrypted volumes this script could detect."
            exit 0
        fi
    }

    macos_make_encrypted_volume() {
        # This script makes it easy to create an encrypted APFS volume. It generates a
        # secure passphrase, creates the volume, and stores the passphrase in the
        # system keychain so that the volume can be automatically decrypted and mounted
        # on boot. We intentionally do not store the volume password in the user's
        # keychain because that keychain may get deleted by password rotation.
        # Spotlight indexing is disabled on the volumes by default to avoid CPU time contention
        # during package caching or checkout.

        echo -e "We need to briefly run as root (through sudo) to store the volume passphrase in the System keychain (${system_keychain_path}) to protect it from deletion during password rotation."
        echo -e "If prompted, please enter your user password."
        sudo -v

        volume_name="$1"

        vol_quota=""
        if [[ -n "$2" ]]; then
            echo -e "Quota for volume ${volume_name} will be: $2\n"
            vol_quota="$2"
        fi

        disk_name=disk1
        if [[ $(arch) == 'arm64' ]]; then
            disk_name=disk3
        fi

        volume_passphrase="$(dd if=/dev/urandom bs=64 count=1 2>/dev/null | base64 | tr -d '\n')"
        /usr/sbin/diskutil apfs addVolume "${disk_name}" 'Case-sensitive APFS' "${volume_name}" -stdinpassphrase "${vol_quota}" <<<"${volume_passphrase}"
        echo -e "Your volume password is: ${volume_passphrase}\n"

        vol_info_file="/tmp/${volume_name}.plist"
        /usr/sbin/diskutil info -plist "${volume_name}" >"${vol_info_file}" || {
            echo "Wrong volume: \"${volume_name}\". Exiting."
            exit 1
        }
        vol_uuid="$(/usr/libexec/PlistBuddy -c 'Print VolumeUUID' "${vol_info_file}")"
        vol_mountPoint="$(/usr/libexec/PlistBuddy -c 'Print MountPoint' "${vol_info_file}")"
        rm "${vol_info_file}"

        # Exclude these volumes from Spotlight indexing to save CPU overhead on large cache updates/git indices
        /usr/bin/mdutil -i off "${vol_mountPoint}"

        system_keychain_path="$(security list-keychains -d system | head -1 | sed -E 's/[ ]+\"(.*)\"/\1/')"

        # We MUST use the interactive mode of security to add the passphrase. Without
        # it the passphrase would be passed as an argument which is insecure.
        # Also, the passphrase must be stored in the system keychain and not login
        # keychain. Some people choose to delete their login keychains during password
        # rotation.
        sudo /usr/bin/security -i <<EOF
add-generic-password \
-a "${vol_uuid}" \
-s "${vol_uuid}" \
-D "Encrypted Volume Password" \
-l "${volume_name}" \
-U \
-T "/System/Library/CoreServices/APFSUserAgent" \
-T "/System/Library/CoreServices/CSUserAgent" \
-T "/usr/bin/security" \
-w "${volume_passphrase}" \
"${system_keychain_path}"
EOF

        echo -e "Volume passphrase has been stored in the System keychain (${system_keychain_path})."
        echo -e "Password rotation process doesn't delete System keychain but it's not a bad idea to back up the volume passphrase in your password safe."
        echo -e "Encrypted volume ${volume_name} (UUID ${vol_uuid}) was successfully created and mounted in ${vol_mountPoint}."
    }

    macos_encrypt_volume() {
        # This script encrypts an existing APFS volume with a very long randomly
        # generated passphrase and stores the passphrase in the System keychain so that
        # the volume can be automatically mounted at startup.

        echo -e "We need to briefly run as root (through sudo) to store the volume passphrase in the System keychain (${system_keychain_path}) to protect it from deletion during password rotation."
        echo -e "If prompted, please enter your user password."
        sudo -v

        volume_name="$1"

        volume_passphrase="$(dd if=/dev/urandom bs=64 count=1 2>/dev/null | base64 | tr -d '\n')"
        echo -e "Your volume passphrase is: ${volume_passphrase}"

        vol_info_file="/tmp/${volume_name}.plist"
        /usr/sbin/diskutil info -plist "${volume_name}" >"${vol_info_file}" || {
            echo "Wrong volume: \"${volume_name}\". Exiting."
            exit 1
        }
        vol_uuid="$(/usr/libexec/PlistBuddy -c 'Print VolumeUUID' "${vol_info_file}")"
        rm "${vol_info_file}"

        /usr/sbin/diskutil apfs encryptVolume "${vol_uuid}" -user disk -stdinpassphrase <<<"${volume_passphrase}" || {
            echo -e "ERROR: Volume encryption failed!"
            echo -e "Volume ${volume_name} (UUID: ${vol_uuid}) might already be encrypted (in that case, it still has the old password, not the one shown above) or something else happened."
            echo -e "See diskutil error message above."
            exit 1
        }

        # Now we need to store volume passphrase in the System keychain.
        system_keychain_path="$(security list-keychains -d system | head -1 | sed -E 's/[ ]+\"(.*)\"/\1/')"

        # We MUST use the interactive mode of security to add the passphrase. Without
        # it the passphrase would be passed as an argument which is insecure.
        # Also, the passphrase must be stored in the system keychain and not login
        # keychain. Some people choose to delete their login keychains during password
        # rotation.
        sudo /usr/bin/security -i <<EOF
add-generic-password \
-a "${vol_uuid}" \
-s "${vol_uuid}" \
-D "Encrypted Volume Password" \
-l "${volume_name}" \
-U \
-T "/System/Library/CoreServices/APFSUserAgent" \
-T "/System/Library/CoreServices/CSUserAgent" \
-T "/usr/bin/security" \
-w "${volume_passphrase}" \
"${system_keychain_path}"
EOF

        echo -e "Volume passphrase has been stored in the System keychain (${system_keychain_path})."
        echo -e "Password rotation process doesn't delete System keychain but it's not a bad idea to back up the volume passphrase in your password safe."
        echo -e "Volume ${volume_name} (UUID ${vol_uuid}) is now being encrypted in the background by an independent macOS system daemon."
        echo -e "You can safely close this shell if you want."
        echo -e "You can verify your volume has been encrypted in Disk Utility app or executing \"diskutil apfs list\" in your shell."
    }

    macos_mount_volume() {
        # Mounts the specified volume at the specified mount point. The script will
        # first attempt to lock the volume to ensure it's operating on a locked volume.
        # Diskutil considering unlocking an already unlocked volume an error.
        #
        # This script is particularly useful when executed from a launchd script stored
        # in /Library/LaunchDaemons at startup. By default, macOS mounts all volumes in
        # /Volumes at startup. If you want to have them mounted elsewhere like I do
        # (e.g., in your home dir), you have to execute this script at startup as root
        # to remount them where you want them.
        #
        # You can use install-apfs-launch-daemon to install the daemon mentioned above.

        if [[ $(id -u) -ne 0 ]]; then
            echo -e "This script must run as root to be able to mount the volume in the home directory."
            exit 1
        fi

        volume_name="$1"
        mount_point="$2"

        if [[ ! -d ${mount_point} ]]; then
            echo -e "Mount point ${mount_point} is not a directory"
            exit 1
        fi

        vol_info_file="/tmp/${volume_name}.plist"

        echo -e "Retrieving diskutil info for ${volume_name}"
        /usr/sbin/diskutil info -plist "${volume_name}" >"${vol_info_file}" || {
            echo -e "Unknown volume: \"${volume_name}\". Exiting."
            exit 1
        }
        vol_uuid="$(/usr/libexec/PlistBuddy -c 'Print VolumeUUID' "${vol_info_file}")"

        # Try to lock the volume first to make sure we're unlocking a locked volume.
        /usr/sbin/diskutil apfs lockVolume "${volume_name}" || true

        echo -e "Retrieving passphrase for ${vol_uuid}"
        volume_passphrase="$(/usr/bin/security find-generic-password -w -l "${volume_name}" -a "${vol_uuid}" -D 'Encrypted Volume Password')"

        echo -e "Unlocking volume ${vol_uuid}"
        /usr/sbin/diskutil apfs unlockVolume "${volume_name}" -stdinpassphrase -mountPoint "${mount_point}" <<<"${volume_passphrase}"

        echo -e "Volume ${volume_name} (UUID: ${vol_uuid}) was successfully mounted at ${mount_point}"
    }

    macos_install_mount_volume_launchd() {

        if [[ $(id -u) -ne 0 ]]; then
            echo -e "This script must run as root to be able to mount the volume in the home directory."
            exit 1
        fi

        volume_name="$1"

        mount_point="$2"

        if [[ ! -d ${mount_point} ]]; then
            echo -e "Mount point ${mount_point} is not a directory"
            exit 1
        fi

        # Now we need to ensure we have a normalized path. The easiest way I found to
        # do this is with a bit of Python. We use an ancient version (2.7) because
        # macOS ships with it.
        mount_point="$(python2.7 -c "import os.path; import sys; print os.path.abspath(sys.argv[1])" "$2")"

        mount_script_path="${this_cli_fullpath} --macos --mount-volume"

        echo -e "Volume name set to: ${volume_name}"
        echo -e "Mount point set to: ${mount_point}"
        echo -e "Full command to add to launchd daemon set to: ${mount_script_path} ${volume_name} ${mount_point}\n"

        vol_info_file="/tmp/${volume_name}.plist"

        echo -e "Retrieving diskutil info for ${volume_name}"
        /usr/sbin/diskutil info -plist "${volume_name}" >"${vol_info_file}" || {
            echo -e "Unknown volume: \"${volume_name}\". Exiting."
            exit 1
        }
        vol_uuid="$(/usr/libexec/PlistBuddy -c 'Print VolumeUUID' "${vol_info_file}")"

        launchd_daemon_path="/Library/LaunchDaemons/mount.${volume_name}.plist"
        echo -e "Writing launchd daemon configuration"

        cat <<EOF | sudo tee "${launchd_daemon_path}" >/dev/null
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>Label</key>
        <string>mount.${volume_name}</string>
        <key>ProgramArguments</key>
        <array>
            <string>${mount_script_path}</string>
            <string>${volume_name}</string>
            <string>${mount_point}</string>
        </array>
        <key>RunAtLoad</key>
        <true/>
        <!-- Logging std out/err is useful for debugging. -->
        <!--
        <key>StandardOutPath</key>
        <string>/tmp/mount-volume-${volume_name}-stdout.log</string>
        <key>StandardErrorPath</key>
        <string>/tmp/mount-volume-${volume_name}-stderr.log</string>
        -->
    </dict>
</plist>
EOF

        echo -e "launchd daemon configuration was successfully written to"
        echo -e "${launchd_daemon_path}\n"

        launchctl unload "${launchd_daemon_path}"
        sleep 1
        launchctl load "${launchd_daemon_path}"
        echo -e "Configuration loaded\n"

        sleep 3 # Sleep a little bit to make sure the script had enough time to mount the volume

        echo -e "Retrieving diskutil info for ${volume_name}"
        /usr/sbin/diskutil info -plist "${volume_name}" >"${vol_info_file}" || {
            echo -e "Unknown volume: \"${volume_name}\". Exiting."
            exit 1
        }
        vol_new_mount_point="$(/usr/libexec/PlistBuddy -c 'Print MountPoint' "${vol_info_file}")"
        echo -e "Volume is now mounted at ${vol_new_mount_point}"

        if [[ "${vol_new_mount_point}" != "${mount_point}" ]]; then
            echo -e "ERROR: the new mount point for the volume was expected to be ${mount_point} but it's ${vol_new_mount_point}"
        fi
    }

    if [[ -z "$1" ]]; then
        arg='-h'
    else
        arg="$1"
    fi

    case "${arg}" in
    -f | --find-unencrypted-volumes)
        macos_find_unencrypted_volumes
        exit 0
        ;;

    -c | --make-encrypted-volume)
        case "$2" in
        -n)
            if [[ -z "$3" ]]; then
                usage
                exit 1
            fi
            case "$4" in
            '')
                macos_make_encrypted_volume "$3"
                exit 0
                ;;
            -q)
                if [[ -z "$5" ]]; then
                    usage
                    exit 1
                fi
                macos_make_encrypted_volume "$3" "$5"
                exit 0
                ;;
            *)
                echo -e "${bold}macos: illegal option -- $*${end}"
                usage
                exit 1
                ;;
            esac
            ;;
        *)
            echo -e "${bold}macos: illegal option -- $*${end}"
            usage
            exit 1
            ;;
        esac
        ;;

    -e | --encrypt-volume)
        case "$2" in
        -n)
            if [[ -z "$3" ]]; then
                usage
                exit 1
            fi
            macos_encrypt_volume "$3"
            ;;
        *)
            echo -e "${bold}macos: illegal option -- $*${end}"
            usage
            exit 1
            ;;
        esac
        ;;

    -m | --mount-volume)
        case "$2" in
        -n)
            if [[ -z "$3" ]]; then
                usage
                exit 1
            fi
            case "$4" in
            -p)
                if [[ -z "$5" ]]; then
                    usage
                    exit 1
                fi
                macos_mount_volume "$3" "$5"
                exit 0
                ;;
            *)
                echo -e "${bold}macos: illegal option -- $*${end}"
                usage
                exit 1
                ;;
            esac
            ;;
        *)
            echo -e "${bold}macos: illegal option -- $*${end}"
            usage
            exit 1
            ;;
        esac
        ;;

    -l | --mount-at-startup)
        case "$2" in
        -n)
            if [[ -z "$3" ]]; then
                usage
                exit 1
            fi
            case "$4" in
            -p)
                if [[ -z "$5" ]]; then
                    usage
                    exit 1
                fi
                macos_install_mount_volume_launchd "$3" "$5"
                exit 0
                ;;
            *)
                echo -e "${bold}macos: illegal option -- $*${end}"
                usage
                exit 1
                ;;
            esac
            ;;
        *)
            echo -e "${bold}macos: illegal option -- $*${end}"
            usage
            exit 1
            ;;
        esac
        ;;

    -h | --help)
        usage
        ;;

    *)
        echo -e "${bold}macos: illegal option -- $*${end}"
        usage
        exit 1
        ;;
    esac

}

########################################################################
# UNISON
########################################################################
unison() {

    unison_terminal_notifier() {
        profile=$1
        end_messages="" # Initialize an empty string to accumulate the [END] lines
        log_file="${HOME}/.unison/unison_${profile}.log"

        # Make sure the log file exists, if not create it
        touch "${log_file}"

        # Run unison with profile
        /opt/homebrew/bin/unison -ui text "$profile" >/dev/null 2>&1 &

        # Follow the log file and process new lines as they are written
        tail -f -n 1 "${log_file}" | while IFS= read -r line; do

            if [[ ${line:0:5} == "[END]" ]]; then
                end_messages+="$line                                 " # Add a newline for each [END] line
                continue                                               # Move to the next iteration without further processing this line
            fi

            if [[ ${line:0:4} == "Sync" ]]; then
                message=${line:39:$((${#line} - 40))}
                message="âœ… SYNC SUCCESSFUL                                      $message                                 $end_messages"

                if [[ ${line:0:26} == "Synchronization incomplete" ]]; then
                    message=${line:41:$((${#line} - 42))}
                    message="âš ï¸ SYNC WARNING                                        $message                                 $end_messages"

                fi
                echo "$message"

                /opt/homebrew/bin/terminal-notifier -message "$message" \
                    -title "UNISON -> ${profile}" \
                    -sound "Default" -group "UNISON-$(date +%s)" \
                    -open "file://${log_file}"

                end_messages="" # Reset end_messages after sending notification to accumulate the [END] lines

            elif [[ ${line:0:11} == "Fatal error" ]]; then
                message=$line
                message="ðŸš¨ SYNC ALERT                                             $message"

                echo "$message"

                /opt/homebrew/bin/terminal-notifier -message "$message" \
                    -title "UNISON ERROR -> ${profile}" \
                    -sound "Default" -group "UNISON-$(date +%s)" \
                    -open "file://${log_file}"

            fi
        done
    }

    unison_launchd_daemon_path="${HOME}/Library/LaunchAgents/com.unison.launchd.agent.plist"
    unison_daily_restart_daemon_path="${HOME}/Library/LaunchAgents/com.unison.daily_restart.agent.plist"

    unison_install_launchd() {
        echo -e "Writing launchd daemon configuration"

        cat <<EOF >"${unison_launchd_daemon_path}"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>EnvironmentVariables</key>
        <dict>
            <key>PATH</key>
            <string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
            <key>HOME</key>
            <string>${HOME}</string>
        </dict>
        <key>Label</key>
        <string>com.unison.launchd.agent</string>
        <key>RunAtLoad</key>
        <true/>
        <key>KeepAlive</key>
        <true/>
        <key>StandardOutPath</key>
        <string>/tmp/com.unison.launchd.agent.log</string>
        <key>StandardErrorPath</key>
        <string>/tmp/com.unison.launchd.agent.log</string>
        <key>ProgramArguments</key>
        <array>
            <string>${this_cli_fullpath}</string>
            <string>--unison</string>
            <string>--run-profiles</string>
        </array>
    </dict>
</plist>
EOF

        cat <<EOF >"${unison_daily_restart_daemon_path}"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>EnvironmentVariables</key>
        <dict>
            <key>PATH</key>
            <string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
            <key>HOME</key>
            <string>${HOME}</string>
        </dict>
        <key>Label</key>
        <string>com.unison.daily_restart.agent</string>
        <key>StartCalendarInterval</key>
        <dict>
            <key>Hour</key>
            <integer>12</integer>
            <key>Minute</key>
            <integer>00</integer>
        </dict>
        <key>StandardOutPath</key>
        <string>/tmp/com.unison.daily_restart.agent.log</string>
        <key>StandardErrorPath</key>
        <string>/tmp/com.unison.daily_restart.agent.log</string>
        <key>ProgramArguments</key>
        <array>
            <string>${this_cli_fullpath}</string>
            <string>--unison</string>
            <string>--start</string>
        </array>
    </dict>
</plist>
EOF

        echo -e "launchd daemon configuration was successfully written to"
        echo -e "${unison_launchd_daemon_path}"
        echo -e "${unison_daily_restart_daemon_path}\n"
    }

    unison_run_profiles() {
        unison_profiles=(
            "prof_workplace"
            "prof_my_lib"
            "prof_devdsk7"
        )

        for unison_profile in "${unison_profiles[@]}"; do
            unison_terminal_notifier "${unison_profile}" &
        done

        # wait to keep the unison profiles running
        wait
    }

    unison_status() {
        echo -e "${bold}${green}[UNISON STATUS]${end}"
        ps aux | grep 'unison -ui' | grep -v grep | awk -v yellow="${yellow}" -v end="${end}" '{print "PID: " $2 yellow " >>> " end "Started: " $9 yellow " >>> " end $11 " " $12 " " $13 " " $14 " " $15 " " $16 " " $17}' || echo -e "No Unison process found."
    }

    unison_start() {
        if [[ ! -t 1 ]]; then
            echo -e "\n\n\n\n\n"
            echo -e "++++++++++++ DEBUGGING INFO ++++++++++++"
            echo -e "icarus --unison --start called at -> $(date)"
            echo
            echo -e "Home var is -> ${HOME}"
            echo
            echo -e "Path var is -> ${PATH}"
            echo
            echo -e "Iam -> $(whoami)"
            echo
            echo -e "I'm in -> $(pwd)"
            echo
            echo -e "agents are located at:"
            echo -e "${unison_launchd_daemon_path}"
            ls -la "${unison_launchd_daemon_path}"
            echo
            echo -e "${unison_daily_restart_daemon_path}"
            ls -la "${unison_daily_restart_daemon_path}"
            echo
            echo -e "active launchd including unison:"
            launchctl list | grep unison || echo "-none found"
            echo -e "++++++++++++++++++++++++++++++++++++++++\n"
        fi

        ${this_cli_fullpath} --unison --stop
        echo -e ""
        sleep 1

        ${this_cli_fullpath} --unison --clear-locks
        echo -e ""
        sleep 1

        ${this_cli_fullpath} --unison --start-at-startup
        sleep 1

        echo -e "Loading launchd daemons configuration"
        echo -e "loading ${unison_launchd_daemon_path}"
        launchctl load "${unison_launchd_daemon_path}"
        echo -e "loading ${unison_daily_restart_daemon_path}"
        launchctl load "${unison_daily_restart_daemon_path}"
        echo -e "Configuration loaded\n"
        echo -e "Starting up Unison..."
        echo -e ""

        sleep 10
        ${this_cli_fullpath} --unison --status
    }

    unison_stop() {
        echo -e "Terminating existing launchd daemons configuration"
        echo -e "unloading ${unison_launchd_daemon_path}"
        launchctl unload "${unison_launchd_daemon_path}" || {
            echo -e "${unison_launchd_daemon_path} failed unload"
        }
        # Only stop the daemon if called by terminal because if it is called by the launch agent
        # this will kill its own process and interrupt the execution.
        if [[ -t 1 ]]; then
            echo -e "unloading ${unison_daily_restart_daemon_path}"
            launchctl unload "${unison_daily_restart_daemon_path}" || {
                echo -e "${unison_daily_restart_daemon_path} failed unload"
            }
        fi
        echo -e "unload completed!"
        sleep 1
        echo -e "Configuration terminated\n"

        echo -e "${bold}${red}[TERMINATING UNISON]${end}"
        ps aux | grep 'unison -ui' | grep -v grep | awk -v red="${red}" -v end="${end}" '{print "Killing PID: " $2"..." red " >>> " end $11 " " $12 " " $13 " " $14 " " $15 " " $16 " " $17}' || echo -e "No Unison process found."
        ps aux | grep 'unison -ui' | grep -v grep | awk '{print $2}' | xargs kill -9 || :
    }

    clear_locks_local_machine() {
        echo -e "Clearing locks on local host..."
        rm -rf -- "${HOME}/.unison/lk"* || exit 0
        echo -e "Local host clear"
    }

    clear_locks_ssh() {
        # Construct the HOSTNAME
        hostname="devdsk$1"
        echo -e "Clearing locks on SSH ${hostname}..."
        ssh "${hostname}" 'rm -rf -- ${HOME}/.unison/lk* || exit  0'
        echo -e "SSH ${hostname} clear"
    }

    if [[ -z "$1" ]]; then
        arg='-h'
    else
        arg="$1"
    fi

    case "${arg}" in
    -i | --status)
        unison_status
        exit 0
        ;;

    -s | --start)
        unison_start
        exit 0
        ;;

    -k | --stop)
        unison_stop
        exit 0
        ;;

    -c | --clear-locks)
        case "$2" in
        '')
            clear_locks_local_machine
            exit 0
            ;;
        -i)
            clear_locks_local_machine
            echo -e "\n"
            clear_locks_ssh "$3"
            exit 0
            ;;
        *)
            echo -e "${bold}unison: illegal option -- $*${end}"
            usage
            exit 1
            ;;
        esac
        ;;

    -l | --start-at-startup)
        unison_install_launchd
        exit 0
        ;;

    # Internally used only, not available in the CLI help page
    --run-profiles)
        unison_run_profiles
        exit 0
        ;;

    -h | --help)
        usage
        ;;

    *)
        echo -e "${bold}unison: illegal option -- $*${end}"
        usage
        exit 1
        ;;
    esac
}

########################################################################
# WELCOME
########################################################################
echo_welcome() {
    echo -e "${bold}"
    echo -e " _)    "
    echo -e "  |   __|   _\` |   __|  |   |   __|"
    echo -e "  |  (     (   |  |     |   | \\__ \\"
    echo -e " _| \\___| \\__,_| _|    \\__,_| ____/${end}"
}

########################################################################
# USAGE
########################################################################
usage() {
    echo -e "${bold}usage: ${cli_name} [COMMAND] [ARGS]${end}"
    echo -e ""
    echo -e "${yellow}[COMMANDS]:${end}"
    echo -e " --amazon                                                               Utilities for Amazon environment."
    echo -e " --builder                                                              Utilities for software development."
    echo -e " --macos                                                                Utilities for MacOS."
    echo -e " --unison                                                               Utilities to manage Unison demon."
    echo -e " -h | --help                                                            Echo this usage list."
    echo -e ""
    echo -e "${yellow}--amazon [ARGS]:${end}"
    echo -e " -a | --auth-init                   [-i DEVDSK_ID]                      Run midway authentication on localhost and optional remote DevDsk(s). Takes multiple ids i.e. -i 1 2 3."
    echo -e " -c | --midway-cookie                                                   Check the cookies validity."
    echo -e " -d | --devdsk-formation            -i DEVDSK_ID                        Run DevDsk Formation on a remote DevDsk."
    echo -e " -s | --update-hosts                                                    Update /etc/hosts file."
    echo -e " -u | --update-hosts-d                                                  Install a LaunchDaemon to update the hosts file every hour."
    echo -e ""
    echo -e "${yellow}--builder [ARGS]:${end}"
    echo -e " -p | --python-package-init         -n PACKAGE_NAME                     Initiate a new Python package in the current folder. [PACKAGE_NAME] in PascalCase."
    echo -e " -d | --dotfiles-update                                                 Update dotfiles from their specified repository."
    echo -e ""
    echo -e "${yellow}--macos [ARGS]:${end}"
    echo -e " -f | --find-unencrypted-volumes                                        Find all unencrypted volumes."
    echo -e " -c | --make-encrypted-volume       -n VOLUME_NAME    [-q QUOTA]        Make an encrypted APFS volume. QUOTA in Gb i.e. -q 50g."
    echo -e " -e | --encrypt-volume              -n VOLUME_NAME                      Encrypt an existing APFS volume."
    echo -e " -m | --mount-volume                -n VOLUME_NAME    -p MOUNT_POINT    Mount the specified volume at the specified mount point."
    echo -e " -l | --mount-at-startup            -n VOLUME_NAME    -p MOUNT_POINT    Install a LaunchDaemon to mount the volume at System Startup."
    echo -e ""
    echo -e "${yellow}--unison [ARGS]:${end}"
    echo -e " -i | --status                                                          Check the running status of each Unison profile."
    echo -e " -s | --start                                                           Start Unison profile(s) sync."
    echo -e " -k | --stop                                                            Stop Unison profile(s) sync."
    echo -e " -c | --clear-locks                 [-i DEVDSK_ID]                      Clear Unison locks on localhost and a optional remote DevDsk."
    echo -e " -l | --start-at-startup                                                Install a LaunchDaemon to start Unison at System Startup."
    echo -e ""
}

########################################################################
# Process the command-line argument
########################################################################

# Parse the command-line arguments
if [[ -z "$1" ]]; then
    arg='-h'
else
    arg="$1"
fi

case "${arg}" in

--amazon)
    amazon "${@:2}"
    ;;
--builder)
    builder "${@:2}"
    ;;
--macos)
    macos "${@:2}"
    ;;
--unison)
    unison "${@:2}"
    ;;

-h | --help)
    echo_welcome
    echo -e ""
    usage
    echo -e ""
    ;;
*)
    echo -e "${bold}${cli_name}: illegal option -- $*${end}"
    usage
    exit 1
    ;;

esac
